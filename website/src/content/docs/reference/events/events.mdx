---
title: Events
sidebar:
  order: 4
---

import { Card } from '@astrojs/starlight/components'

<Card icon="warning">
This page is needs to be rewritten. Please reach out in Discord if you have any related questions.
</Card>

## Commiting events

```ts
// events.ts
import { Events } from '@livestore/livestore'

export const todoCreated = Events.synced({
  name: 'todoCreated',
  schema: Schema.Struct({ id: Schema.String, text: Schema.String }),
})

// somewhere in your app
store.commit(
	todoCreated({ id: '1', text: 'Buy milk' })
)
```

## Best Practices

- It's strongly recommended to use past-tense event names (e.g. `todoCreated`/`createdTodo` instead of `todoCreate`/`createTodo`) to indicate something already occurred.
- TODO: write down more best practices
- TODO: mention AI linting (either manually or via a CI step)
  - core idea: feed list of best practices to AI and check if events adhere to them + get suggestions if not
- It's recommended to avoid `DELETE` events and instead use soft-deletes (e.g. add a `deleted` date/boolean column with a default value of `null`). This helps avoid some common concurrency issues.

## Rules of Events

### Schema evolution

- Event definitions can't be removed after they were added to your app.
- Event schema definitions can be evolved as long as the changes are forward-compatible.
  - That means data encoded with the old schema can be decoded with the new schema.
	- In practice, this means ...
	  - for structs ...
			- you can add new fields if they have default values or are optional
			- you can remove fields

### Other Notes

- Events need to be deterministic. This means that the same input will always produce the same output.
- When re-using existing schema definitions for event schemas, be careful to also apply the rules of events to the schema definitions you are re-using. A more conservative approach is to copy the schema definitions and evolve them separately.
